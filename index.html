<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>To</title>
    <style>
        /* å…¨å±€æ ·å¼ - æ‰‹æœºä¼˜åŒ– */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #02040c; 
            font-family: 'Times New Roman', serif, 'PingFang SC', 'Microsoft YaHei', sans-serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        /* 1. åœºæ™¯å›¾å±‚ */
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        #fireworks-canvas { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 2; 
            pointer-events: none; 
        }
        
        /* 2. UIå±‚ (æ ‡é¢˜) */
        #ui-layer {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 5; 
            pointer-events: none;
            display: flex; 
            flex-direction: column; 
            align-items: center;
            padding-top: 8vh;
            box-sizing: border-box;
            transition: opacity 1s;
        }

        .greeting-container {
            text-align: left;
            padding: 0 20px;
        }

        h1 { 
            color: #fceea7; 
            font-size: min(6.5vw, 36px); 
            margin: 0; 
            font-weight: 400; 
            letter-spacing: 3px; 
            text-shadow: 0 0 20px rgba(252, 238, 167, 0.6); 
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Cinzel', 'Times New Roman', serif, 'PingFang SC', 'Microsoft YaHei';
            opacity: 0.9;
            line-height: 1.2;
            margin-bottom: 5px;
        }

        h2 {
            color: #f0d699; 
            font-size: min(4.5vw, 24px); 
            margin: 0; 
            font-weight: 300; 
            letter-spacing: 1.5px; 
            text-shadow: 0 0 15px rgba(240, 214, 153, 0.5); 
            font-family: 'Times New Roman', serif, 'PingFang SC', 'Microsoft YaHei';
            opacity: 0.85;
            line-height: 1.3;
            font-style: italic;
        }

        /* äº¤äº’æç¤º */
        .interaction-hint {
            position: absolute;
            bottom: 25px;
            left: 0;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            letter-spacing: 1px;
            z-index: 10;
            pointer-events: none;
            padding: 0 20px;
            box-sizing: border-box;
        }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            color: #d4af37;
            text-align: center;
            transition: opacity 0.5s;
        }

        .spinner { 
            width: 40px; 
            height: 40px; 
            border: 2px solid rgba(212, 175, 55, 0.2); 
            border-top: 2px solid #d4af37; 
            border-radius: 50%; 
            animation: spin 1s infinite linear; 
            margin: 0 auto 15px auto; 
        }
        @keyframes spin { 
            to { 
                transform: rotate(360deg); 
            } 
        }
        .loader-text { 
            font-size: 13px; 
            letter-spacing: 2px; 
            text-transform: uppercase; 
            color: #aaa; 
            text-align: center; 
            line-height: 1.5; 
            padding: 0 20px;
        }

        /* æ‰‹æœºä¼˜åŒ– */
        @media (max-width: 768px) {
            h1 { 
                font-size: min(7vw, 32px); 
                letter-spacing: 2.5px; 
            }
            
            h2 {
                font-size: min(5vw, 20px); 
                letter-spacing: 1.2px;
            }
            
            .interaction-hint {
                font-size: 12px;
                bottom: 20px;
            }
            
            #ui-layer {
                padding-top: 10vh;
            }
        }

        @media (max-width: 480px) {
            h1 { 
                font-size: min(8vw, 28px); 
                letter-spacing: 2px; 
            }
            
            h2 {
                font-size: min(6vw, 18px); 
                letter-spacing: 1px;
            }
            
            #ui-layer {
                padding-top: 12vh;
            }
        }

    </style>
    <style>@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');</style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- åŠ è½½æç¤º -->
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">åŠ è½½åœ£è¯é­”æ³•...</div>
    </div>

    <!-- ä¸»åœºæ™¯ -->
    <div id="canvas-container"></div>
    <canvas id="fireworks-canvas"></canvas>

    <div id="ui-layer">
        <div class="greeting-container">
            <h1 id="to-line">To: æ—å­çª</h1>
            <h2 id="wish-line">ä¸–ç•Œæ¸©æŸ” ä¸‡ç‰©å¯çˆ± ä½ ä¹Ÿæ˜¯ ğŸ„</h2>
        </div>
    </div>
    
    <!-- äº¤äº’æç¤º -->
    <div class="interaction-hint" id="interaction-hint" style="display: none;">
        ç‚¹å‡»å±å¹•å˜æ¢å½¢æ€ â€¢ ç‚¹å‡»ç…§ç‰‡æ”¾å¤§ â€¢ å†æ¬¡ç‚¹å‡»è¿”å›
    </div>

    <script>
        // --- é…ç½®å‚æ•° ---
        const CONFIG = {
            // ç¥ç¦è¯­é…ç½® - å¯ä»¥ç›´æ¥åœ¨è¿™é‡Œä¿®æ”¹
            greeting: {
                // ç¬¬ä¸€è¡Œï¼šæ¥æ”¶è€…
                to: "æ—å­çª",
                // ç¬¬äºŒè¡Œï¼šç¥ç¦è¯­
                wish: "ä¸–ç•Œæ¸©æŸ” ä¸‡ç‰©å¯çˆ± ä½ ä¹Ÿæ˜¯ ğŸ„"
            },
            
            // æœ¬åœ°ç…§ç‰‡è·¯å¾„ - å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æœ¬åœ°å›¾ç‰‡è·¯å¾„
            localPhotos: [
                // ç¤ºä¾‹ï¼šæ·»åŠ æœ¬åœ°å›¾ç‰‡ï¼ˆéœ€è¦å°†å›¾ç‰‡æ”¾åœ¨åŒä¸€ç›®å½•æˆ–æŒ‡å®šè·¯å¾„ï¼‰
                // {src: "images/photo1.jpg", aspect: 4/3},
                // {src: "images/photo2.jpg", aspect: 16/9},
                // å¦‚æœæ²¡æœ‰æœ¬åœ°å›¾ç‰‡ï¼Œå¯ä»¥ä½¿ç”¨é»˜è®¤çš„åœ£è¯ä¸»é¢˜å›¾ç‰‡
                // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªåœ¨çº¿åœ£è¯å›¾ç‰‡ä½œä¸ºç¤ºä¾‹ï¼Œå®é™…ä½¿ç”¨æ—¶å¯ä»¥æ›¿æ¢ä¸ºæœ¬åœ°è·¯å¾„
                {src: "./images/1.jpeg", aspect: 4/3},
                {src: "./images/2.jpeg", aspect: 4/3},
                {src: "./images/3.jpeg", aspect: 16/9},
                {src: "./images/4.jpeg", aspect: 16/9},
                {src: "./images/1.jpeg", aspect: 4/3},
                {src: "./images/2.jpeg", aspect: 4/3},
                {src: "./images/3.jpeg", aspect: 16/9},
                {src: "./images/4.jpeg", aspect: 16/9}
            ],
            
            // æ˜¯å¦è‡ªåŠ¨æ·»åŠ ç¤ºä¾‹ç…§ç‰‡ï¼ˆå¦‚æœæ²¡æœ‰æœ¬åœ°ç…§ç‰‡ï¼‰
            useDefaultPhotos: true
        };

        // --- é¡µé¢åŠ è½½æ—¶ç›´æ¥åˆå§‹åŒ– ---
        window.onload = () => {
            // è®¾ç½®ç¥ç¦è¯­
            document.getElementById('to-line').innerText = `To: ${CONFIG.greeting.to}`;
            document.getElementById('wish-line').innerText = CONFIG.greeting.wish;
            
            // å¯åŠ¨3Då¼•æ“
            if (window.startThreeEngine) {
                window.startThreeEngine();
                
                // æ·»åŠ æœ¬åœ°ç…§ç‰‡åˆ°åœºæ™¯
                if (CONFIG.localPhotos.length > 0 && window.addPhotosToRunningScene) {
                    setTimeout(() => {
                        window.addPhotosToRunningScene(CONFIG.localPhotos);
                    }, 500);
                }
                
                // æ˜¾ç¤ºäº¤äº’æç¤º
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => {
                        document.getElementById('loader').style.display = 'none';
                        document.getElementById('interaction-hint').style.display = 'block';
                        if(window.activateInteraction) window.activateInteraction();
                    }, 500);
                }, 1500);
            }
        };

        // é˜²æ­¢æ‰‹æœºç«¯åŒå‡»ç¼©æ”¾
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // é‡æ–°åŠ è½½å¿«æ·é”®
        window.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'r') location.reload();
        });
        
        // ç¥ç¦è¯­ç¼–è¾‘æç¤ºï¼ˆå¼€å‘è€…ç”¨ï¼‰
        console.log("ğŸ„ åœ£è¯ç¥ç¦é…ç½®æç¤º ğŸ„");
        console.log("å¦‚éœ€ä¿®æ”¹ç¥ç¦è¯­ï¼Œè¯·åœ¨ä»£ç ä¸­ä¿®æ”¹CONFIG.greetingå¯¹è±¡ï¼š");
        console.log("1. ä¿®æ”¹toå­—æ®µæ›´æ”¹æ¥æ”¶è€…åç§°");
        console.log("2. ä¿®æ”¹wishå­—æ®µæ›´æ”¹ç¥ç¦å†…å®¹");
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 

        // --- çƒŸèŠ±æ•ˆæœ ---
        const fwCanvas = document.getElementById('fireworks-canvas');
        const fwCtx = fwCanvas.getContext('2d');
        let fwWidth, fwHeight, fwScale;
        let particles = [];
        let smokes = [];
        
        // åˆ›å»ºå‘å…‰æ•ˆæœ
        const glowCanvas = document.createElement('canvas'); 
        glowCanvas.width = 32; 
        glowCanvas.height = 32;
        const gCtx = glowCanvas.getContext('2d'); 
        const gradG = gCtx.createRadialGradient(16, 16, 0, 16, 16, 16); 
        gradG.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
        gradG.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)'); 
        gradG.addColorStop(1, 'rgba(255, 255, 255, 0)'); 
        gCtx.fillStyle = gradG; 
        gCtx.fillRect(0, 0, 32, 32);
        
        // åˆ›å»ºçƒŸé›¾æ•ˆæœ
        const smokeCanvas = document.createElement('canvas'); 
        smokeCanvas.width = 128; 
        smokeCanvas.height = 128;
        const smCtx = smokeCanvas.getContext('2d'); 
        const smGrad = smCtx.createRadialGradient(64, 64, 0, 64, 64, 64); 
        smGrad.addColorStop(0, 'rgba(160, 160, 170, 0.8)'); 
        smGrad.addColorStop(0.3, 'rgba(120, 120, 130, 0.3)'); 
        smGrad.addColorStop(1, 'rgba(80, 80, 90, 0)'); 
        smCtx.fillStyle = smGrad; 
        smCtx.fillRect(0, 0, 128, 128);
        
        // å·¥å…·å‡½æ•°
        const random = (min, max) => Math.random() * (max - min) + min;
        const SPEED_MOD = 0.7; 

        // çƒŸé›¾ç±»
        class Smoke { 
            constructor(x, y) { 
                this.x = x; 
                this.y = y; 
                this.vx = random(-0.25, 0.25) * fwScale * SPEED_MOD; 
                this.vy = random(-0.15, 0.15) * fwScale * SPEED_MOD; 
                this.size = random(20, 45) * fwScale; 
                this.growth = random(0.15, 0.3) * fwScale * SPEED_MOD; 
                this.life = random(60, 100) / SPEED_MOD; 
                this.maxLife = this.life; 
                this.alphaStart = random(0.15, 0.3); 
            } 
            update() { 
                this.x += this.vx; 
                this.y += this.vy; 
                this.size += this.growth; 
                this.life--; 
                return this.life > 0; 
            } 
            draw() { 
                const progress = this.life / this.maxLife; 
                const currentAlpha = this.alphaStart * Math.pow(progress, 2.0); 
                if (currentAlpha > 0.005) { 
                    fwCtx.save(); 
                    fwCtx.globalCompositeOperation = 'source-over'; 
                    fwCtx.globalAlpha = currentAlpha; 
                    const drawSize = this.size * 2; 
                    fwCtx.drawImage(smokeCanvas, this.x - drawSize/2, this.y - drawSize/2, drawSize, drawSize); 
                    fwCtx.restore(); 
                } 
            } 
        }
        
        // ç«èŠ±ç±»
        class Spark { 
            constructor(x, y, vx, vy, isGlitter = false) { 
                this.x = x; 
                this.y = y; 
                this.isGlitter = isGlitter; 
                if (isGlitter) { 
                    this.vx = (vx * 0.1 + random(-0.5, 0.5) * fwScale) * SPEED_MOD; 
                    this.vy = (vy * 0.1 + random(-0.5, 0.5) * fwScale) * SPEED_MOD; 
                    this.friction = 0.92; 
                    this.gravity = 0.015 * fwScale * SPEED_MOD; 
                    this.life = random(60, 100) / SPEED_MOD; 
                    this.maxLife = this.life; 
                    this.size = random(1, 2.5) * fwScale; 
                    this.flickerSpeed = random(0.3, 0.6) * SPEED_MOD; 
                } else { 
                    this.vx = (vx * 0.3 + random(-1.5, 1.5) * fwScale) * SPEED_MOD; 
                    this.vy = (vy * 0.3 + random(-1.5, 1.5) * fwScale) * SPEED_MOD; 
                    this.friction = 0.96; 
                    this.gravity = 0.06 * fwScale * SPEED_MOD; 
                    this.life = random(40, 80) / SPEED_MOD; 
                    this.maxLife = this.life; 
                    this.size = random(1, 3) * fwScale; 
                    this.flickerSpeed = random(0.1, 0.3) * SPEED_MOD; 
                } 
                this.flickerOffset = random(0, 100); 
            } 
            update() { 
                this.vx *= this.friction; 
                this.vy *= this.friction; 
                this.vy += this.gravity; 
                this.x += this.vx; 
                this.y += this.vy; 
                this.life -= 1; 
                return this.life > 0; 
            } 
            draw() { 
                const flicker = Math.abs(Math.sin(this.life * this.flickerSpeed + this.flickerOffset)); 
                const baseAlpha = this.life / this.maxLife; 
                let finalAlpha, r, g, b; 
                if (this.isGlitter) { 
                    finalAlpha = baseAlpha * (0.3 + flicker * 0.7); 
                    r = 255; 
                    g = 255; 
                    b = 255; 
                } else { 
                    finalAlpha = baseAlpha * (0.3 + flicker * 0.7); 
                    r = 255; 
                    g = 220; 
                    b = 150; 
                    if (this.life < 20) { 
                        g = 150; 
                        b = 50; 
                    } 
                } 
                fwCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${finalAlpha})`; 
                fwCtx.beginPath(); 
                fwCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
                fwCtx.fill(); 
            } 
        }
        
        // å‚æŸ³çƒŸèŠ±ç²’å­ç±»
        class WillowParticle { 
            constructor(x, y, angle, speed, colorType, depthScale) { 
                this.x = x; 
                this.y = y; 
                this.vx = Math.cos(angle) * speed * SPEED_MOD; 
                this.vy = Math.sin(angle) * speed * SPEED_MOD; 
                this.friction = 0.94; 
                this.gravity = 0.07 * fwScale * SPEED_MOD; 
                this.life = random(180, 250) / SPEED_MOD; 
                this.maxLife = this.life; 
                this.trail = []; 
                this.maxTrail = 20; 
                this.colorType = colorType; 
                this.depthScale = depthScale; 
                this.width = (colorType === 'gold' ? 3.0 : 2.0) * fwScale * depthScale; 
            } 
            update() { 
                this.trail.push({x: this.x, y: this.y}); 
                if(this.trail.length > this.maxTrail) this.trail.shift(); 
                this.vx *= this.friction; 
                this.vy *= this.friction; 
                this.vy += this.gravity; 
                this.x += this.vx; 
                this.y += this.vy; 
                this.life--; 
                if(this.life % 8 === 0) smokes.push(new Smoke(this.x, this.y)); 
                return this.life > 0; 
            } 
            draw() { 
                if(this.trail.length < 2) return; 
                const progress = this.life / this.maxLife; 
                const alpha = Math.min(1, progress * 3); 
                fwCtx.beginPath(); 
                fwCtx.moveTo(this.trail[0].x, this.trail[0].y); 
                for(let i=1; i<this.trail.length; i++) fwCtx.lineTo(this.trail[i].x, this.trail[i].y); 
                fwCtx.lineTo(this.x, this.y); 
                fwCtx.lineCap = 'round'; 
                fwCtx.lineWidth = this.width * alpha; 
                let strokeStyle = `rgba(255, 240, 150, ${alpha})`; 
                if(this.colorType === 'red') strokeStyle = `rgba(255, 80, 80, ${alpha})`; 
                else if(this.colorType === 'blue') strokeStyle = `rgba(80, 180, 255, ${alpha})`; 
                fwCtx.strokeStyle = strokeStyle; 
                fwCtx.stroke(); 
                if (progress > 0.05) { 
                    const s = this.width * 2.5; 
                    fwCtx.drawImage(glowCanvas, this.x - s/2, this.y - s/2, s, s); 
                } 
            } 
        }
        
        // çƒŸèŠ±å¼¹ç±»
        class Shell { 
            constructor(x, y, targetX, targetY, type, depthScale) { 
                this.x = x; 
                this.y = y; 
                this.targetY = targetY; 
                this.type = type; 
                this.depthScale = depthScale; 
                const g = 0.15 * fwScale * SPEED_MOD; 
                const dy = y - targetY; 
                const vy = Math.sqrt(2 * g * dy); 
                const t = vy / g; 
                const dx = targetX - x; 
                const vx = dx / t; 
                this.vx = vx; 
                this.vy = -vy; 
                this.gravity = g; 
                this.isDead = false; 
            } 
            update() { 
                this.vy += this.gravity; 
                this.x += this.vx; 
                this.y += this.vy; 
                if (Math.random() > 0.7) smokes.push(new Smoke(this.x, this.y)); 
                if (this.vy >= 0) { 
                    this.isDead = true; 
                    if(this.type === 'willow') explodeWillow(this.x, this.y, this.depthScale); 
                    else if(this.type === 'comet') explodeComet(this.x, this.y); 
                    for(let i=0; i<6; i++) smokes.push(new Smoke(this.x + random(-10,10), this.y + random(-10,10))); 
                } 
                return !this.isDead; 
            } 
            draw() { 
                const size = 6 * fwScale * this.depthScale; 
                fwCtx.drawImage(glowCanvas, this.x - size, this.y - size, size*2, size*2); 
                fwCtx.beginPath(); 
                fwCtx.moveTo(this.x, this.y); 
                fwCtx.lineTo(this.x - this.vx*2.5, this.y - this.vy*2.5); 
                fwCtx.lineCap = 'round'; 
                fwCtx.strokeStyle = 'rgba(255, 200, 100, 0.3)'; 
                fwCtx.lineWidth = 8 * fwScale; 
                fwCtx.stroke(); 
                fwCtx.beginPath(); 
                fwCtx.moveTo(this.x, this.y); 
                fwCtx.lineTo(this.x - this.vx*2.5, this.y - this.vy*2.5); 
                fwCtx.strokeStyle = 'rgba(255, 255, 220, 0.95)'; 
                fwCtx.lineWidth = 3 * fwScale; 
                fwCtx.stroke(); 
            } 
        }

        // çˆ†ç‚¸æ•ˆæœå‡½æ•°
        function explodeWillow(x, y, depthScale) { 
            const count = 80; 
            const colors = ['gold', 'red', 'blue']; 
            for(let i=0; i<count; i++) { 
                const angle = random(0, Math.PI*2); 
                const speed = random(5, 22) * fwScale * depthScale; 
                const color = colors[Math.floor(Math.random() * colors.length)]; 
                particles.push(new WillowParticle(x, y, angle, speed, color, depthScale)); 
            } 
        }
        
        function explodeComet(x, y) { 
            for(let k=0; k<15; k++) { 
                const ang = random(0, Math.PI*2); 
                const spd = random(2, 8) * fwScale; 
                particles.push(new Spark(x, y, Math.cos(ang)*spd, Math.sin(ang)*spd, true)); 
            } 
        }
        
        // è°ƒæ•´çƒŸèŠ±ç”»å¸ƒå¤§å°
        function resizeFireworks() { 
            fwWidth = fwCanvas.width = window.innerWidth; 
            fwHeight = fwCanvas.height = window.innerHeight; 
            fwScale = Math.min(fwWidth, fwHeight) / 900; 
        }
        
        // è§¦å‘çƒŸèŠ±æ•ˆæœ
        function triggerChapter3Fireworks() {
            const cx = fwWidth / 2; 
            const targetBaseY = fwHeight * 0.25; 
            const spreadW = fwWidth * 0.6; 
            const startX = cx - spreadW / 2; 
            const stepX = spreadW / 4; 
            
            for(let i=0; i<5; i++) { 
                const targetX = startX + stepX * i; 
                const targetY = targetBaseY + random(-50, 50) * fwScale; 
                const depth = random(0.8, 1.2); 
                setTimeout(() => { 
                    particles.push(new Shell(cx, fwHeight, targetX, targetY, 'willow', depth)); 
                }, i * 200); 
            }
            
            setTimeout(() => { 
                const groundY = fwHeight; 
                for(let i=0; i<6; i++) { 
                    const x = (i < 3) ? (fwWidth * 0.15 + i*30*fwScale) : (fwWidth * 0.85 - (i-3)*30*fwScale); 
                    const tx = x + (i<3 ? 50 : -50)*fwScale; 
                    setTimeout(() => { 
                        particles.push(new Shell(x, groundY, tx, fwHeight*0.6, 'comet', 0.8)); 
                    }, i * 150); 
                } 
            }, 1200);
            
            setTimeout(() => { 
                for(let i=0; i<3; i++) { 
                    const x = cx + (i-1)*200*fwScale; 
                    setTimeout(() => { 
                        particles.push(new Shell(x, fwHeight, x, fwHeight*0.3, 'willow', 1.0)); 
                    }, i*300); 
                } 
            }, 2000);
        }

        // ==========================================
        // ç¬¬äºŒéƒ¨åˆ†: 3Då¼•æ“
        // ==========================================
        const ENGINE_CONFIG = { 
            colors: { 
                bg: 0x02040c, 
                gold: 0xffd966, 
                green: 0x03180a, 
                red: 0x990000 
            }, 
            particles: { 
                count: 1800, 
                treeHeight: 24, 
                treeRadius: 8.5 
            }, 
            snow: { 
                count: 1500, 
                speed: 3.5 
            }, 
            camera: { 
                z: 50 
            } 
        };
        
        // çŠ¶æ€ç®¡ç†
        const STATE = { 
            mode: 'TREE', 
            focusTarget: null, 
            rotation: { x: 0, y: 0 }, 
            photoIndex: -1, 
            hasExpandedOnce: false, 
            interactionEnabled: false,
            autoRotate: true
        };
        
        let scene, camera, renderer, composer, mainGroup; 
        let clock = new THREE.Clock();
        let particleSystem = []; 
        let snowSystem;
        let raycaster = new THREE.Raycaster(); 
        let mouse = new THREE.Vector2();

        // å…¨å±€å‡½æ•° - ä¾›ä¸»è„šæœ¬è°ƒç”¨
        window.startThreeEngine = function() {
            initThree();
            createSceneContent();
            resizeFireworks();
            setupInteraction();
            animate();
            
            // é¡µé¢åŠ è½½åè‡ªåŠ¨æ’­æ”¾ä¸€äº›çƒŸèŠ±
            setTimeout(() => {
                triggerChapter3Fireworks();
            }, 3000);
        };

        // æ·»åŠ ç…§ç‰‡åˆ°è¿è¡Œä¸­çš„åœºæ™¯
        window.addPhotosToRunningScene = function(photos) {
            if (!photos || photos.length === 0) return;
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loader = document.getElementById('loader');
            loader.innerHTML = '<div class="spinner"></div><div class="loader-text">åŠ è½½ç…§ç‰‡ä¸­...</div>';
            loader.style.display = 'block';
            loader.style.opacity = '1';
            
            let loadedCount = 0;
            const totalPhotos = photos.length;
            
            photos.forEach(photoData => {
                const img = new Image();
                img.crossOrigin = "anonymous"; // å…è®¸è·¨åŸŸå›¾ç‰‡
                img.onload = function() {
                    loadedCount++;
                    const aspect = img.width / img.height;
                    addPhotoParticle(photoData.src, aspect);
                    
                    // æ‰€æœ‰ç…§ç‰‡åŠ è½½å®Œæˆåéšè—åŠ è½½æç¤º
                    if (loadedCount === totalPhotos) {
                        setTimeout(() => {
                            loader.style.opacity = '0';
                            setTimeout(() => {
                                loader.style.display = 'none';
                            }, 500);
                        }, 500);
                    }
                };
                img.onerror = function() {
                    loadedCount++;
                    console.warn("æ— æ³•åŠ è½½å›¾ç‰‡:", photoData.src);
                    // å¦‚æœæ‰€æœ‰ç…§ç‰‡éƒ½åŠ è½½å¤±è´¥ï¼Œä¹Ÿéšè—åŠ è½½æç¤º
                    if (loadedCount === totalPhotos) {
                        loader.style.opacity = '0';
                        setTimeout(() => {
                            loader.style.display = 'none';
                        }, 500);
                    }
                };
                img.src = photoData.src;
            });
        };

        // å¯ç”¨äº¤äº’
        window.activateInteraction = function() {
            setTimeout(() => {
                STATE.interactionEnabled = true;
            }, 1000);
        };

        // åˆå§‹åŒ–Three.js
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(ENGINE_CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(ENGINE_CONFIG.colors.bg, 0.015); 
            
            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, ENGINE_CONFIG.camera.z); 
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false, 
                powerPreference: "high-performance",
                preserveDrawingBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; 
            renderer.toneMappingExposure = 2.2; 
            container.appendChild(renderer.domElement);
            
            mainGroup = new THREE.Group();
            mainGroup.position.y = -1.0; 
            scene.add(mainGroup);
            
            // åæœŸå¤„ç†
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.7; 
            bloomPass.strength = 0.45; 
            bloomPass.radius = 0.4;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            
            // ç…§æ˜
            scene.add(new THREE.AmbientLight(0xffffff, 0.7)); 
            
            const spotGold = new THREE.SpotLight(0xffcc66, 2000); 
            spotGold.position.set(30, 40, 40);
            spotGold.angle = 0.5; 
            spotGold.penumbra = 0.5;
            scene.add(spotGold);
            
            const spotBlue = new THREE.SpotLight(0x6688ff, 600);
            spotBlue.position.set(-30, 20, -30);
            scene.add(spotBlue);
            
            const fill = new THREE.DirectionalLight(0xffeebb, 0.6);
            fill.position.set(0, 0, 50);
            scene.add(fill);
        }

        // åˆ›å»ºåœºæ™¯å†…å®¹
        function createSceneContent() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
            
            const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);
            const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32); 
            
            // æè´¨
            const goldMat = new THREE.MeshStandardMaterial({ 
                color: ENGINE_CONFIG.colors.gold, 
                metalness: 1.0, 
                roughness: 0.1, 
                envMapIntensity: 2.0, 
                emissive: 0x443300, 
                emissiveIntensity: 0.4 
            });
            
            const greenMat = new THREE.MeshStandardMaterial({ 
                color: ENGINE_CONFIG.colors.green, 
                metalness: 0.2, 
                roughness: 0.8, 
                emissive: 0x002200, 
                emissiveIntensity: 0.3 
            });
            
            const redMat = new THREE.MeshPhysicalMaterial({ 
                color: ENGINE_CONFIG.colors.red, 
                metalness: 0.3, 
                roughness: 0.2, 
                clearcoat: 1.0 
            });

            // åˆ›å»ºç²’å­
            for (let i = 0; i < ENGINE_CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type;
                
                if (rand < 0.4) { 
                    mesh = new THREE.Mesh(boxGeo, greenMat); 
                    type = 'BOX'; 
                }
                else if (rand < 0.7) { 
                    mesh = new THREE.Mesh(boxGeo, goldMat); 
                    type = 'GOLD_BOX'; 
                }
                else if (rand < 0.9) { 
                    mesh = new THREE.Mesh(sphereGeo, goldMat); 
                    type = 'GOLD_SPHERE'; 
                }
                else { 
                    mesh = new THREE.Mesh(sphereGeo, redMat); 
                    type = 'RED'; 
                }
                
                const s = 0.4 + Math.random() * 0.5;
                mesh.scale.set(s,s,s);
                mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type, false));
            }
            
            // åˆ›å»ºæ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(1.2, 0);
            const starMat = new THREE.MeshStandardMaterial({ 
                color: 0xffdd88, 
                emissive: 0xffaa00, 
                emissiveIntensity: 1.0, 
                metalness: 1.0, 
                roughness: 0 
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, ENGINE_CONFIG.particles.treeHeight/2 + 1.2, 0);
            mainGroup.add(star);
            
            createSnow();
        }

        // æ·»åŠ ç…§ç‰‡ç²’å­
        function addPhotoParticle(src, aspect) {
            const tex = new THREE.TextureLoader().load(src);
            tex.colorSpace = THREE.SRGBColorSpace;
            const baseH = 1.2;
            const baseW = baseH * aspect;
            
            // ç›¸æ¡†
            const frameGeo = new THREE.BoxGeometry(baseW + 0.2, baseH + 0.2, 0.05);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: ENGINE_CONFIG.colors.gold, 
                metalness: 1.0, 
                roughness: 0.2 
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            
            // ç…§ç‰‡
            const photoGeo = new THREE.PlaneGeometry(baseW, baseH);
            const photoMat = new THREE.MeshBasicMaterial({ map: tex });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.03;
            
            // ç»„åˆ
            const group = new THREE.Group();
            group.add(frame);
            group.add(photo);
            group.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
            mainGroup.add(group);
            
            particleSystem.push(new Particle(group, 'PHOTO', false));
        }

        // ç²’å­ç±»
        class Particle {
            constructor(mesh, type, isDust) {
                this.mesh = mesh;
                this.type = type;
                this.baseScale = mesh.scale.x;
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                
                // è®¡ç®—åœ¨æ ‘ä¸Šçš„ä½ç½®
                const h = ENGINE_CONFIG.particles.treeHeight;
                let t = Math.pow(Math.random(), 1.5);
                const y = (t * h) - h/2;
                let rMax = ENGINE_CONFIG.particles.treeRadius * (1.0 - t);
                if (rMax < 0.5) rMax = 0.5;
                const r = rMax * (0.2 + 0.8 * Math.sqrt(Math.random())); 
                const angle = t * 60 * Math.PI + Math.random() * Math.PI * 2;
                this.posTree.set(Math.cos(angle)*r, y, Math.sin(angle)*r);

                // è®¡ç®—åˆ†æ•£ä½ç½®
                let rScatter = 10 + Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta), 
                    rScatter * Math.sin(phi) * Math.sin(theta), 
                    rScatter * Math.cos(phi)
                );
                
                const spinMult = 8.0; 
                this.spinSpeed = new THREE.Vector3(
                    (Math.random()-0.5) * spinMult, 
                    (Math.random()-0.5) * spinMult, 
                    (Math.random()-0.5) * spinMult
                );
            }

            update(dt, mode, focusTargetMesh) {
                let target = this.posTree;
                let s = this.baseScale;
                
                if (mode === 'SCATTER') {
                    target = this.posScatter;
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                    this.mesh.rotation.z += this.spinSpeed.z * dt;
                    
                    if (this.type === 'PHOTO') {
                        s = this.baseScale * 2.5; 
                        this.mesh.rotation.x *= 0.9; 
                        this.mesh.rotation.y *= 0.9; 
                        this.mesh.rotation.z *= 0.9;
                    }
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        const desiredWorldPos = new THREE.Vector3(0, 2, 35);
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                        this.mesh.lookAt(camera.position); 
                        s = 4.5; 
                    } else {
                        target = this.posScatter; 
                        s = (this.type === 'PHOTO') ? this.baseScale * 2.0 : this.baseScale * 0.8;
                    }
                } else {
                    // æ ‘æ¨¡å¼ä¸‹ç¼“æ…¢æ—‹è½¬
                    this.mesh.rotation.x *= 0.95; 
                    this.mesh.rotation.z *= 0.95;
                }
                
                const lerpSpeed = 2.5; 
                this.mesh.position.lerp(target, lerpSpeed * dt);
                this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4.0 * dt);
            }
        }

        // åˆ›å»ºé›ªèŠ±
        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = []; 
            const vel = [];
            
            for(let i=0; i<ENGINE_CONFIG.snow.count; i++) {
                pos.push(
                    (Math.random()-0.5)*80, 
                    (Math.random()-0.5)*80+10, 
                    (Math.random()-0.5)*80
                );
                vel.push(
                    (Math.random()-0.5)*0.5, 
                    -(Math.random()*0.5+0.5)*ENGINE_CONFIG.snow.speed, 
                    (Math.random()-0.5)*0.5
                );
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.userData = { vel: vel };
            
            // åˆ›å»ºé›ªèŠ±çº¹ç†
            const cvs = document.createElement('canvas'); 
            cvs.width=32; 
            cvs.height=32;
            const ctx = cvs.getContext('2d');
            const gr = ctx.createRadialGradient(16,16,0,16,16,16);
            gr.addColorStop(0,'rgba(255,255,255,1)'); 
            gr.addColorStop(1,'rgba(255,255,255,0)');
            ctx.fillStyle=gr; 
            ctx.fillRect(0,0,32,32);
            
            const mat = new THREE.PointsMaterial({ 
                size: 0.6, 
                map: new THREE.CanvasTexture(cvs), 
                transparent: true, 
                opacity: 0.8, 
                blending: THREE.AdditiveBlending, 
                depthWrite: false 
            });
            
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        // æ”¹å˜çŠ¶æ€
        function changeState(newState) {
            if (STATE.mode === newState) return;
            
            // çƒŸèŠ±æ•ˆæœé€»è¾‘ï¼šåªåœ¨ä»åˆ†æ•£çŠ¶æ€å›åˆ°æ ‘çŠ¶æ€æ—¶è§¦å‘ï¼Œå¹¶ä¸”å·²ç»å±•å¼€è¿‡ä¸€æ¬¡
            if (newState === 'SCATTER') {
                STATE.hasExpandedOnce = true;
                STATE.autoRotate = false;
            }
            
            if (newState === 'TREE' && STATE.mode === 'SCATTER' && STATE.hasExpandedOnce) {
                triggerChapter3Fireworks();
                STATE.autoRotate = true;
            }
            
            STATE.mode = newState;
            STATE.focusTarget = null;
        }

        // è®¾ç½®äº¤äº’
        function setupInteraction() {
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                resizeFireworks();
            }, false);

            // ç‚¹å‡»äº‹ä»¶å¤„ç†
            const onClick = (event) => {
                if (!STATE.interactionEnabled) return;

                // è®¡ç®—é¼ æ ‡ä½ç½®
                if (event.type === 'touchstart') {
                    event.preventDefault();
                    mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                } else {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                }
                
                // å°„çº¿æ£€æµ‹
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(mainGroup.children, true);
                
                // çŠ¶æ€åˆ‡æ¢é€»è¾‘
                if (STATE.mode === 'TREE') {
                    // æ ‘çŠ¶æ€ -> åˆ†æ•£çŠ¶æ€
                    changeState('SCATTER');
                } else if (STATE.mode === 'SCATTER') {
                    // åˆ†æ•£çŠ¶æ€ï¼šæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†ç…§ç‰‡
                    let hitPhoto = false;
                    for (let hit of intersects) {
                        let obj = hit.object;
                        // æ‰¾åˆ°çˆ¶çº§ç»„
                        while(obj.parent && obj.parent !== mainGroup) obj = obj.parent;
                        const p = particleSystem.find(p => p.mesh === obj);
                        if (p && p.type === 'PHOTO') {
                            // è¿›å…¥èšç„¦çŠ¶æ€
                            STATE.mode = 'FOCUS';
                            STATE.focusTarget = p.mesh;
                            // é‡ç½®ç´¢å¼•
                            const photos = particleSystem.filter(pt => pt.type === 'PHOTO');
                            STATE.photoIndex = photos.indexOf(p);
                            hitPhoto = true;
                            break;
                        }
                    }
                    // å¦‚æœæ²¡æœ‰ç‚¹å‡»ç…§ç‰‡ï¼Œè¿”å›æ ‘çŠ¶æ€
                    if (!hitPhoto) changeState('TREE');
                } else if (STATE.mode === 'FOCUS') {
                    // èšç„¦çŠ¶æ€ -> åˆ†æ•£çŠ¶æ€
                    changeState('SCATTER');
                }
            };
            
            // äº‹ä»¶ç›‘å¬
            window.addEventListener('mousedown', onClick, false);
            window.addEventListener('touchstart', onClick, { passive: false });
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            // æ›´æ–°çƒŸèŠ±æ•ˆæœ
            fwCtx.clearRect(0, 0, fwWidth, fwHeight);
            fwCtx.globalCompositeOperation = 'lighter';
            
            // æ›´æ–°çƒŸé›¾
            let sIdx = smokes.length; 
            while(sIdx--) { 
                if(!smokes[sIdx].update()) smokes.splice(sIdx, 1); 
                else smokes[sIdx].draw(); 
            }
            
            // æ›´æ–°ç²’å­
            let pIdx = particles.length; 
            while(pIdx--) { 
                if(!particles[pIdx].update()) particles.splice(pIdx, 1); 
                else particles[pIdx].draw(); 
            }
            
            // æ›´æ–°é›ªèŠ±
            if (snowSystem) {
                const pos = snowSystem.geometry.attributes.position.array;
                const vel = snowSystem.geometry.userData.vel;
                for(let i=0; i<ENGINE_CONFIG.snow.count; i++) {
                    pos[i*3+1] += vel[i*3+1] * dt * 5.0; 
                    pos[i*3] += Math.sin(clock.elapsedTime+i)*0.02;
                    if(pos[i*3+1] < -20) pos[i*3+1] = 40;
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // è‡ªåŠ¨æ—‹è½¬é€»è¾‘
            if (STATE.autoRotate) {
                STATE.rotation.y += 0.3 * dt;
                STATE.rotation.x *= 0.95;
            } else if (STATE.mode === 'SCATTER') {
                // åˆ†æ•£çŠ¶æ€æ—¶ç¼“æ…¢æ—‹è½¬
                STATE.rotation.y += 0.1 * dt;
            }
            
            // åº”ç”¨æ—‹è½¬
            mainGroup.rotation.x = STATE.rotation.x; 
            mainGroup.rotation.y = STATE.rotation.y;
            
            // æ›´æ–°ç²’å­ç³»ç»Ÿ
            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            
            // æ¸²æŸ“åœºæ™¯
            composer.render();
        }
    </script>
</body>
</html>